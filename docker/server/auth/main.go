// @title Gba File/JWT Auth Server
// @version 1.0
// @description This server is designed to provide jwt token support/local file handling to my gbajs implementation

// @contact.name Nicholas VanCise
// @contact.url https://nicholas-vancise.dev
// @contact.email nvancisedev@gmail.com
// @license.name Copyright (c) 2022 Nicholas VanCise

package main

import (
	_ "auth-server/docs" // docs is generated by Swag CLI, you have to import it.
	"fmt"
	gz "github.com/NYTimes/gziphandler"
	"github.com/gorilla/mux"
	"github.com/natefinch/lumberjack"
	"github.com/rs/cors"
	"github.com/satori/go.uuid"
	"github.com/swaggo/http-swagger"
	"github.com/glebarez/sqlite"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"log"
	"net/http"
	"os"
	"time"
)

const (
	romPath = "./local_roms/"
	savePath = "./local_saves/"
	certLoc = "./certs/fullchain.pem"
	keyLoc = "./certs/privkey.pem"
)

var (
	userdb        *gorm.DB
	AccessSignKey []byte
)

func serveRequests(port string, certloc string, keyloc string, client_host string) {
	router := mux.NewRouter().StrictSlash(false)
	//here are our handlers for paths to different actions performed by this api are set up, defined in paths.go
	for _, route := range ROUTES {
		if !no_auth_routes[route.pattern] { //path requires authorization
			route.handler = authorize(route.handler).(http.HandlerFunc)
		}

		route.handler = gz.GzipHandler(route.handler).(http.HandlerFunc) //default gzip middleware if accepted

		router.Handle(route.pattern, route.handler).Methods(route.method)
	}

	//cors support
	c := cors.New(cors.Options{
		AllowedOrigins:   []string{client_host},
		AllowCredentials: true,
		AllowedMethods:   []string{"GET", "POST", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Content-Type", "Content-Length", "Accept-Encoding", "Authorization", "X-Real-Ip", "X-Forwarded-For", "Host", "User-Agent", "Connection"},
		ExposedHeaders:   []string{"Set-Cookie"},
		Debug:            false,
	})

	//below for eventual permanent swagger docs
	/*myRouter.PathPrefix("/documentation/").Handler(httpSwagger.Handler( //if we ever have a stable api deployment, this can be used to make it searchable
		httpSwagger.URL("http://localhost:8081/documentation/doc.json"), //The url pointing to API definition"
	))*/
	router.PathPrefix("/api/documentation/").Handler(httpSwagger.WrapHandler) //here is where I have added the swagger endpoint

	log.Fatal(http.ListenAndServeTLS(port, certloc, keyloc, c.Handler(router))) //the port and address for api set here, provided from the properties file
}

func main() {
	fmt.Println("In main, gba/jwt auth server started")
	var err error
	AccessSignKey = uuid.Must(uuid.NewV4(), err).Bytes()
	if err != nil {
		fmt.Println("failed to create initial access secret")
		return
	}
	clientHost := os.Getenv("CLIENT_HOST")

	logfile := &lumberjack.Logger{ //handle rolling logs internally
		Filename:   "./logs/auth_server_log.log",
		MaxSize:    50, // megabytes
		MaxBackups: 5,
		MaxAge:     15,   //days
		Compress:   true, // disabled by default
	}
	log.SetOutput(logfile)

	gconf := &gorm.Config{
		PrepareStmt: true,
		Logger: logger.New(
			log.New(logfile, fmt.Sprintf("\n%s [DEBUG] ", time.Now().String())+"\r\n", 0), // io writer
			logger.Config{
				SlowThreshold:             time.Second,  // Slow SQL threshold
				LogLevel:                  logger.Error, // Log level
				IgnoreRecordNotFoundError: true,         // Ignore ErrRecordNotFound error for logger
				Colorful:                  false,        // Disable color
			},
		),
	}

	userdb, err = gorm.Open(sqlite.Open("users.db"), gconf)

	if err != nil {
		fmt.Println("Error, could not connect to users db")
		panic(err)
	}

	userdb.AutoMigrate(&User{})

	log.Println("handling requests initiated")
	serveRequests(":443", certLoc, keyLoc, clientHost) //start server
}
